## Go Course

Code generated by following the Course https://app.pluralsight.com/player?course=go&author=john-sonmez&name=go-m2-development


Run
```
#> go run <file-name>
```

Compile
```
#> go build <file-name>
```


Brackets should be in-line of a function, otherwize it will throw an Compiler Error, because Go Compiler adds a semicolon (;) at
the end of every line.

```
func main (){

}

func main ()       //This will fail... Thanks God!
{

}

```

#### Variables
---------
Variables should be defined with the Type after it:

```
var message string = "Hello Go World"

```

We also can define multiple variables at the same line, as well with their values:

```
var a,b,c int = 1,2,3
```

It is not required to specify the type of a variable when we are declaring it, the following syntax is valid:
```
var message = "Hello Go World"
```

We can even go a step further and declare a variable without the *var* keyword:

```
message := "Hello Go World"

a,b,c := 1, false, "String!"  //This even works with multiple declaration in one line

```

#### Pointers
----------
Pointers behave as the old fashion C/C++ where:
- they have to be defined as a pointer of the variable type using an asterisk (*)
- you can set/access the actual value of the variable using ampersand (&)
- you can alter the value of the variable using the pointer

```
var someString = "the value"
var *somePointer = &someString  //Setting the pointer

fmt.Println(someString,somePointer)  //This would print something like "the value 0xc42000e1d0"
fmt.Println(someString,&somePointer)  //This would print something like "the value the value"

*somePointer = "hi there"  //We modify the value of the address

fmt.Println(someString,somePointer)  //This would print something like "hi there 0xc42000e1d0"
fmt.Println(someString,&somePointer)  //This would print something like "hi there hi there"

```

#### User Types
---------
Remember Structs on C/C++ ? well, they are back!!

You can define your own type of variable/object in order to gather the values that you need in a single instance/object.
This User Type can be accessed from outside the package *only if* you define it with a Capital, otherwise it will be private

```
type MyStruct struct{
	name string
	lastName string
}
```

This Types can be initialized in three different ways:

```
var myVar = MyStruct{"el Name","el LastName"}
var myVar2 = MyStruct{lastName:"el LastName",name:"el Name"}
var myVar3 = MyStruct{}
```

To get and set the values we just do as follow:
```

myVar.name = "El Name"  //To Set
fmt.Println(myVar.lastName) //To get and print it
```

#### Constants
----------

You can define constants to have read-only values for your program:

```
const PI=3.14
```

You can also define a set of constants using parenthesis to group them:
 ```
 const (
    PI=3.14
    Lang="Go"
 )
```

#### Functions
--------
Functions is Go are pretty normal, they are basically a piece of code that you might use multiple times and you write it
wrapped with a name, so you can call/use it everywhere.

The basic syntax is:
```
func myfunction(parameter <type>) <return-type>{
    //Some code
    return <value>
}
```

#### *But wait!*
Go have some new interesting features with the functions like:

**Multiple Returns**

We can return two or more values from a single function:
```
func myFunction(parameter <type>)(<return-type>,<return-type>...){
    //Some Code
    return <value1>,<value2>
}
```
**Multiple Named Returns**

To avoid confusions on the multiple returns, we can name them and assign the value to a variable that will be returned
at the end of the function:
```
func myFunction(parameter <type>)(<variable1> <return-type>,<variable2> <return-type>){
    //Some Code
    <variable1>=value
    //Some more code
    <variable2>=value
    return  // We do not need to explicitly return the values in this line because we are setting the return value to a
            // variable that is defined into the method signature
}
```
**Variadic Functions**

That's just a fancy name to say _I might not know how many parameter my function will handle_ and the syntax is:

```
func myFunction(parameter ...<type>){
    //Some Code
    value= parameter[<position>]  // With Variadic functions, the unknown parameters arrive as an array and we can access
                                  // the values using an index
}
```

**Passing a Function**

Or known as _Higher Order Functions_, if you want to pass a function to another function, you can just treat it as any other object

```
func myFunction(<function_alias> func(<parameter-type>), parameter <type>){
    <function_alias>(parameter)
}


```

**Function Type**

This is too similar to Passing a Function, but instead of having an _unknown_ function, we can define the
signature of the function that can be sent as a parameter:
```
type <type-name> func(<param-type>)() //With empty parenthesis to show there's no return value

func myFunction(<function-alias> <type-name>, param <type>){
    <funtion-alias>(param)
}
```

**Closures**

Have you ever work with them in JS? no? Then they will be a headache for you as they are for me. jk, they are just a
function that references variables from outside its body but that were available at the moment of it's declaration.

For a more detailed description, check [this article](https://www.calhoun.io/what-is-a-closure/)

```
package main

import "fmt"

func main() {
  n := 0
  counter := func() int {
    n += 1
    return n
  }
  fmt.Println(counter())
  fmt.Println(counter())
}
```

